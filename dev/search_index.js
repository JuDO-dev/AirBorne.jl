var documenterSearchIndex = {"docs":
[{"location":"pages/contributionGuidelines/#Contribution-Guidelines","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"This notes are meant for developers wanting to contribute to this project. We follow the ColPrac guide for collaborative practices. New contributors should make sure to read that guide as well as the best practices immediately below.","category":"page"},{"location":"pages/contributionGuidelines/#Best-practices-for-merging","page":"Contribution Guidelines","title":"Best practices for merging","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"This guide of best practices are to help developers understand the code written, to ensure good documentation is available for end users and guarantee robustness of the code.","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"Function docstrings: Each function needs to be adequately documented, with inputs and outputs defined. On examples try using jldoctest language type instead of julia except for OS/circumstance specific examples.\nModule docstrings: Each module needs to have a docstring explaining its function and what it represents\nRespect unit tests: Unit tests are put for a reason, make sure all pass before merging into a shared development branch. The reason for the unit test should be indicated somewhere in the code.\nRespect style: Havin a consistent writing style help the developers read the code and brings homogeneity to the contributions. To do this we adhere to te Blue style. ","category":"page"},{"location":"pages/contributionGuidelines/#Branch-Management","page":"Contribution Guidelines","title":"Branch Management","text":"","category":"section"},{"location":"pages/contributionGuidelines/#Versioning","page":"Contribution Guidelines","title":"Versioning","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"When this package is released it will have a version. Versioning is a standard practice in software development, but different approaches are available to define the versions of a package. Usually a package will have the version defined by 3 number which are Major,Minor, Patch. AirBorne 0.1.3 has Major version 0, Minor version 1 and Patch version 3. ","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"Patch: The patch is incremented if a bug has been fix, but no additional feature has been added.\nMinor: The minor is incremented if a new feature, such as new function or submodule or even additional functionalities for existing functions are added. The new minor version needs to be compatible with all previous minor version of the same major version. Therefore if a unit test passes for a minor version it also needs to pass for any further minor version released, and is the responsibility of the newer minor version to comply with this, the sole exception is for undetected bugs, which needs to be corrected immediately in the minor version in which was detected.\nMajor: A major version is incremented if the change in the software is so large that backwards compatibility is impossible. This is a worst case scenario and must be avoided at all costs, existing users of AirBorne will have their code crash, several issues are expected after a major release, it must be done strategically and for very well justified reasons.","category":"page"},{"location":"pages/contributionGuidelines/#Unit-Test-result","page":"Contribution Guidelines","title":"Unit Test result","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"Each minor version of AirBorne will have at least 2 associated branches \"dev-Major.Minor.Patch\" and \"master-Major.Minor.Patch\", merge requests on either of these branches need to pass, local development branches are to be merged \"dev-Major.Minor.Patch\" were limited localized unit-test may be carried out and once the patch is ready for release that branch is merged into \"master-Major.Minor.Patch\" any merge request into the master branch needs to pass a through run of unit tests.","category":"page"},{"location":"pages/contributionGuidelines/#Support","page":"Contribution Guidelines","title":"Support","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"Each minor version needs to be adequately supported as it is to be considered a finished product available for the wider public to use.","category":"page"},{"location":"pages/contributionGuidelines/#Archiving","page":"Contribution Guidelines","title":"Archiving","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"Sometimes we want to keep a branch with some data, but at the same time we don't want to pollute the list of branches in the repository. A way to achieve this is through the usage of tags. The archived branches can be accessed later on by looking at the tags of the repository, following GitHub instructions.","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"# For example we may want to archive or restore the add-quandl branch when picking up the connection to the datasource Quandl. \nexport BRANCH=add-quandl\n# Tag branch (this will add it to the archive)\ngit tag archive/$BRANCH $BRANCH\n# Push the tag to remote\ngit push origin archive/$BRANCH\n# Deleate head of branch (this will remove it from the list)\ngit push origin --delete $BRANCH\n# This will restore the branch\ngit checkout -b $BRANCH archive/$BRANCH","category":"page"},{"location":"pages/contributionGuidelines/#Citation-and-credits","page":"Contribution Guidelines","title":"Citation and credits","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"It is important to identify and credit the contributors of this project, in particular the ones that will act as a point of contact for external enquiries. To do this we put in place a CITATION.cff file that should follow the schema of Github's citation guidelines. ","category":"page"},{"location":"pages/contributionGuidelines/#Local-environment-for-development","page":"Contribution Guidelines","title":"Local environment for development","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"This section is meant for new joiners or people new to software development. If you already know about local environments and have your own style to generate functional code, feel free to skip this section.","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"In this repository you can find a local environment in which the package is guaranteed to work, to do so we leverage docker containers.","category":"page"},{"location":"pages/contributionGuidelines/#Setting-up-a-local-environment","page":"Contribution Guidelines","title":"Setting up a local environment","text":"","category":"section"},{"location":"pages/contributionGuidelines/#How-to-import-package","page":"Contribution Guidelines","title":"How to import package","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"Until package is released, the package can be locally imported by using ","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"develop \"../AirBorne\"","category":"page"},{"location":"pages/contributionGuidelines/#How-to-test-connection-to-GitHub","page":"Contribution Guidelines","title":"How to test connection to GitHub","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"For some operations connection to GitHub may be required, to test your SSH connection in the console use the command below: ","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"ssh -T git@github.com","category":"page"},{"location":"pages/contributionGuidelines/#How-to-perform-unit-tests-efficiently","page":"Contribution Guidelines","title":"How to perform unit tests efficiently","text":"","category":"section"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"Unit testing when executed for the first time takes long, most of the time is taken in compilation. This formula will let you compile once and then execute tests rapidly.","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"First open a console in the testing environment.","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"make J","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"Then execute the following three commands in the newly open Julia console:","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"# Activate Test Environment & Dependencies\nusing TestEnv;TestEnv.activate(); using Revise\n\n# Run all tests\ninclude(\"test/runtests.jl\")\n\n# Run individual tests in a file.\n# include(\"test/test_file.jl\")\n# include(\"test/backtest_A.jl\")\n# include(\"test/FM.jl\")","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"using Revise\nOpen the Pkg REPL using ] and type: dev \"../AirBorne\"\nGo back using backspace and use include(\"test/runtests.jl\")","category":"page"},{"location":"pages/contributionGuidelines/","page":"Contribution Guidelines","title":"Contribution Guidelines","text":"Now anytime you want to test your code again type include(\"test/runtests.jl\") (or just use the up arrow to select the last command that ran).","category":"page"},{"location":"pages/etl/etl/#ETL-Pipeline.","page":"Data Pipeline","title":"ETL Pipeline.","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"ETL, standing for Extract, Transform and Load, is the process of combining data from multiple sources into a large central repository of data. What is ETL? (AWS)","category":"page"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"This package should have an ETL capability to retrieve and store financial data ","category":"page"},{"location":"pages/etl/etl/#.-Extract","page":"Data Pipeline","title":"1. Extract","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"Data can extracted from:","category":"page"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"APIs of data providers such as Quandl or Yahoo\nAPIs of brokers such as Alpaca\nLocal files such as CSVs or JSON with a predetermined format","category":"page"},{"location":"pages/etl/etl/#.-Transform","page":"Data Pipeline","title":"2. Transform","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"Once the data is extracted it locally is formatted and cleaned to standarize the format and schema they should comply with.","category":"page"},{"location":"pages/etl/etl/#.-Load","page":"Data Pipeline","title":"3. Load","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"Lastly the data is served into a variable accessible for the package and persisted in an efficient file format.","category":"page"},{"location":"pages/etl/etl/#Cache-Structure","page":"Data Pipeline","title":"Cache Structure","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"Caching is the local storage of information. Once data has been gathered from a datasource such as Yahoo Finance, Quandl or even simply loaded in memory from a file. Once can choose to store this data so that it can be efficiently retrieved once again by AirBorne.","category":"page"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"The features we aim to obtain with caching are the following:","category":"page"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"I/O Speed: Loading and storing data should be fast, faster than the average loading from a CSV or JSON file. And definitely faster than any API call. \nIntuitive: Users should not have to struggle to retrieve data or store data, if possible this should be done seamlessly in the workflow of the user.\nVersion Controlled: We all make mistakes and sometimes we would like to roll back changes made to our data. This should be possible to achieve.\nStandardized: Although is good to have ample formats available when it comes to storage is good to have standard file formats, this makes the data compliant with many algorithms as the algorithms will be designed with this standard in mind. This also greatly helps speed as the load and storage of data happen in a predefined manner.","category":"page"},{"location":"pages/etl/etl/#How-does-it-work?","page":"Data Pipeline","title":"How does it work?","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"First one needs a cache folder, which can be set by the environment variable AIRBORNE_ROOT. If this variable is not defined for Linux and MacOS it will defaulted to /root/tmp/.AirBorne/.cache whilst in windows it shall be $HOME/.AirBorne/.cache\".","category":"page"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"On said folder there will be many subdirectories, each one corresponding to a separate data bundle. A bundle is the most fundamental level of cache, that is composed by 3 elements. The data file, which is stored in Parquet Format, the metadata that is attached to the parquet file itself, and the archive subfolder containing previous iterations of the cached file.","category":"page"},{"location":"pages/etl/etl/#Supported-schemas-and-file-structure","page":"Data Pipeline","title":"Supported schemas and file structure","text":"","category":"section"},{"location":"pages/etl/etl/#OHLCV","page":"Data Pipeline","title":"OHLCV","text":"","category":"section"},{"location":"pages/etl/etl/#File-structures-on-other-platforms","page":"Data Pipeline","title":"File structures on other platforms","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"Many trading platforms have their own schemas for data","category":"page"},{"location":"pages/etl/etl/#Zorro's","page":"Data Pipeline","title":"Zorro's","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"The zorro project have what they call the T file formats, where a tx file a timestamp \"t\" and x elements. These files are CSV or JSON files stored in ","category":"page"},{"location":"pages/etl/etl/#Headers:","page":"Data Pipeline","title":"Headers:","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"Start - token name or start string of the whole price structure. Determines from where to parse.\nTimeformat - format of the date/time field with DATE format codes, as in the CSV format string.\nTime - token name of the date/time field.\nHigh,Low,Open,Close - token names of the price fields.\nAdjClose - token name of the adjusted close field, or empty if the file contains no such field.\nVolume - toke name of the volume field, or empty if the file contains no volume data.\nAsk - token name of the best ask quote field.\nAskSize - token name of the ask size field.\nBid - token name of the best bid quote field, or empty if the file contains no bid quotes.\nBidSize - token name of the bid size field, or empty.","category":"page"},{"location":"pages/etl/etl/#File-Format:","page":"Data Pipeline","title":"File Format:","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"typedef struct T1\n{\n  DATE  time; // UTC timestamp of the tick in DATE format\n  float fPrice; // price data, positive for ask and negative for bid\n} T1;\n \ntypedef struct T2\n{\n  DATE time;  // UTC timestamp in DATE format\n  float fPrice; // price, negative for bid quotes\n  float fVol; // trade volume or ask/bid size\n} T2; \n \ntypedef struct T6\n{\n  DATE  time; // UTC timestamp of the close, DATE format\n  float fHigh,fLow;\t\n  float fOpen,fClose;\t\n  float fVal,fVol; // additional data, ask-bid spread, volume etc.\n} T6;\n \ntypedef struct CONTRACT\n{\n  DATE  time;   // UTC timestamp in DATE format\n  float fAsk,fBid; // premium without multiplier\n  float fVal,fVol;  // additional data, like delta, open interest, etc.\n  float fUnl;   // underlying price (unadjusted)\n  float fStrike; // strike price\n  long  Expiry; // YYYYMMDD format\n  long  Type;   // PUT, CALL, FUTURE, EUROPEAN, BINARY\n} CONTRACT;","category":"page"},{"location":"pages/etl/etl/#Zipline","page":"Data Pipeline","title":"Zipline","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"Zipline uses what they call OHLCV format, standing for Open, High, Low, Close, Volume. Is a common format to convey daily trade information about a ticker, in addition to the columns in the name actually more columns need to be provided.","category":"page"},{"location":"pages/etl/etl/#File-Format:-2","page":"Data Pipeline","title":"File Format:","text":"","category":"section"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"Zipline actually stores data in a file system. Given a persistency (or cache) directory. It stores the data in bundles stored the following structure $CACHE_PATH/{source_id}/{bundle_id}/ the bundle is then formed in bcolz format","category":"page"},{"location":"pages/etl/etl/","page":"Data Pipeline","title":"Data Pipeline","text":"Zipline OHLCV: Date, Open, High, Low, Close, Volume, Dividend, Split","category":"page"},{"location":"pages/highLevelDesign/#High-Level-Design","page":"Glossary","title":"High Level Design","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"In this section definition for the main objects in this package are presented as well as an introduction to the main logic behind the structure of the package.","category":"page"},{"location":"pages/highLevelDesign/#ETL-Pipeline","page":"Glossary","title":"ETL Pipeline","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"ETL, standing for Extract, Transform and Load, is the process of combining data from multiple sources into a large central repository of data. What is ETL? (AWS)","category":"page"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"This package needs to have an ETL capability to retrieve and store financial data, for reproducibility and post-analytics purposes.","category":"page"},{"location":"pages/highLevelDesign/#Objects","page":"Glossary","title":"Objects","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"In this section we will describe the objects present in the package, some are related to physical and financial entities found in the real world. To ensure our definitions well aligned with the financial we leverage most of the definitions from well established financial entities and/or acadamic sources. In particular IG International Limited: Glossary of Trading Terms is substantially used to support our definitions.","category":"page"},{"location":"pages/highLevelDesign/#Financial-Entities:","page":"Glossary","title":"Financial Entities:","text":"","category":"section"},{"location":"pages/highLevelDesign/#Investor","page":"Glossary","title":"Investor","text":"","category":"section"},{"location":"pages/highLevelDesign/#Broker","page":"Glossary","title":"Broker","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Definition from IG International Limited: A broker is an independent person or a company that organises and executes financial transactions on behalf of another party. They can do this across a number of different asset classes, including stocks, forex, real estate and insurance. A broker will normally charge a commission for the order to be executed. Some brokers will provide you with market data and give you advice on the products you want to buy or sell – depending on whether they are a full service broker, or execution only. However, a broker must be licensed to give advice and execute the sale, and they will only perform trades on your behalf once you have given them the go-ahead.","category":"page"},{"location":"pages/highLevelDesign/#Market","page":"Glossary","title":"Market","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Definition from IG International Limited: A financial market is defined as a medium through which assets are traded, enabling buyers and sellers to interact and facilitate exchanges. However, the term can be used in a variety of different ways – it can refer physical places, virtual exchanges or groups of people that are interested in making transactions.","category":"page"},{"location":"pages/highLevelDesign/#Financial-constructs-and-instruments","page":"Glossary","title":"Financial constructs and instruments","text":"","category":"section"},{"location":"pages/highLevelDesign/#Currency","page":"Glossary","title":"Currency","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Investopedia definition  Currency is a medium of exchange for goods and services. In short, it's money, in the form of paper and coins, usually issued by a government and generally accepted at its face value as a method of payment.","category":"page"},{"location":"pages/highLevelDesign/#Asset","page":"Glossary","title":"Asset","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Definition from IG International Limited: An asset is an economic resource which can be owned or controlled to return a profit, or a future benefit. In financial trading, the term asset relates to what is being exchanged on markets, such as stocks, bonds, currencies or commodities.","category":"page"},{"location":"pages/highLevelDesign/#Spread","page":"Glossary","title":"Spread","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Definition from IG International Limited: In finance, the spread is the difference in price between the buy (bid) and sell (offer) prices quoted for an asset.","category":"page"},{"location":"pages/highLevelDesign/#Position","page":"Glossary","title":"Position","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Definition from IG International Limited: A position is the expression of a market commitment, or exposure, held by a trader. It is the financial term for a trade that is either currently able to incur a profit or a loss – known as an open position – or a trade that has recently been cancelled, known as a closed position. Profit or loss on a position can only be realised once it has been closed.","category":"page"},{"location":"pages/highLevelDesign/#Option","page":"Glossary","title":"Option","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Definition from IG International Limited: An option is a financial instrument that offers you the right – but not the obligation – to buy or sell an asset when its price moves beyond a certain price with a set time period.","category":"page"},{"location":"pages/highLevelDesign/#Portfolio","page":"Glossary","title":"Portfolio","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Definition from IG International Limited: A portfolio refers to group of assets that are held by a trader or trading company. Assets in a portfolio can come in many forms, including stocks, bonds, commodities or derivatives.","category":"page"},{"location":"pages/highLevelDesign/#Technical-Objects","page":"Glossary","title":"Technical Objects","text":"","category":"section"},{"location":"pages/highLevelDesign/#Simulations-and-Backtesting","page":"Glossary","title":"Simulations and Backtesting","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"In this section we will describe different calculations and methods used for the backtesting or simulation of a strategy.","category":"page"},{"location":"pages/highLevelDesign/#Portfolio-calculations-/-Financial-reports","page":"Glossary","title":"Portfolio calculations / Financial reports","text":"","category":"section"},{"location":"pages/highLevelDesign/#Returns","page":"Glossary","title":"Returns","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Definition from IG International Limited:  Rate of return (ROR) is the loss or gain of an investment over a certain period, expressed as a percentage of the initial cost of the investment. A positive ROR means the position has made a profit, while a negative ROR means a loss. You will have a rate of return on any investment you make.","category":"page"},{"location":"pages/highLevelDesign/#PnL:-Profit-and-Losses","page":"Glossary","title":"PnL: Profit and Losses","text":"","category":"section"},{"location":"pages/highLevelDesign/","page":"Glossary","title":"Glossary","text":"Definition from IG International Limited:  A profit and loss (P&L) statement is a financial report that provides a summary of a company’s revenue, expenses and profit. It gives investors and other interested parties an insight into how a company is operating and whether it has the ability to generate a profit.","category":"page"},{"location":"pages/autodocs/","page":"Autodocs","title":"Autodocs","text":"CurrentModule = AirBorne","category":"page"},{"location":"pages/autodocs/#Automated-Documentation","page":"Autodocs","title":"Automated Documentation","text":"","category":"section"},{"location":"pages/autodocs/","page":"Autodocs","title":"Autodocs","text":"Welcome to the documentation for AirBorne!","category":"page"},{"location":"pages/autodocs/","page":"Autodocs","title":"Autodocs","text":"These are the autodocs generated by Documenter.jl. ","category":"page"},{"location":"pages/autodocs/#Index","page":"Autodocs","title":"Index","text":"","category":"section"},{"location":"pages/autodocs/","page":"Autodocs","title":"Autodocs","text":"","category":"page"},{"location":"pages/autodocs/#Autodocs","page":"Autodocs","title":"Autodocs","text":"","category":"section"},{"location":"pages/autodocs/","page":"Autodocs","title":"Autodocs","text":"Modules = [AirBorne,AirBorne.Structures,AirBorne.Utils]","category":"page"},{"location":"pages/autodocs/#AirBorne.Money","page":"Autodocs","title":"AirBorne.Money","text":"Just a float with an associated Symbol\n\n\n\n\n\n","category":"type"},{"location":"pages/autodocs/#AirBorne.Wallet","page":"Autodocs","title":"AirBorne.Wallet","text":"Just a wrapper around a dictionary\n\n\n\n\n\n","category":"type"},{"location":"pages/autodocs/#AirBorne.get_symbol-Union{Tuple{Type{Money{S}}}, Tuple{S}} where S","page":"Autodocs","title":"AirBorne.get_symbol","text":"Retrieves the symbol (the currency) of the money\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.sameCurrency-Union{Tuple{D}, Tuple{S}, Tuple{Money{S}, Money{D}}} where {S, D}","page":"Autodocs","title":"AirBorne.sameCurrency","text":"Indicates if 2 Money instances have the same currency\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#Base.:==-Tuple{Wallet, Wallet}","page":"Autodocs","title":"Base.:==","text":"Test if Wallets are identical. Potentially can be redefined as ===  and leave == if different keys are set to 0\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Structures","page":"Autodocs","title":"AirBorne.Structures","text":"Structures\n\nThis module provides data structures defined and used in the Backtest process.\n\nFacilitating contract enforcement between Engines, Markets and Strategies.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.Structures.ContextTypeA","page":"Autodocs","title":"AirBorne.Structures.ContextTypeA","text":"Context definitions for contract between Engines, Markets and Strategies to operate with.\n\n\n\n\n\n","category":"type"},{"location":"pages/autodocs/#AirBorne.Structures.ContextTypeB","page":"Autodocs","title":"AirBorne.Structures.ContextTypeB","text":"This context allows for arithmetic operations of portfolio and accounts, such as adding  securities by doing portfolio+=security, and or removing Money from an account by doing account+=money.\n\nA way to initialize this this context type can look like:\n\nusing AirBorne.Structures: ContextTypeB, TimeEvent\nusing Dates: now\nstart_event = TimeEvent(now(),\"hi\")\nnew_context = ContextTypeB(start_event)\n\n\n\n\n\n","category":"type"},{"location":"pages/autodocs/#AirBorne.Structures.nextDay!-Tuple{AirBorne.Structures.ContextTypeA}","page":"Autodocs","title":"AirBorne.Structures.nextDay!","text":"nextDay!(context::ContextTypeA;days::Day=Day(1))\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Structures.summarizePerformance-Tuple{DataFrames.DataFrame, AirBorne.Structures.ContextTypeA}","page":"Autodocs","title":"AirBorne.Structures.summarizePerformance","text":"summarizePerformance(data::DataFrame, context::ContextTypeA;\nvaluationFun::Function=stockValuation,\nremoveWeekend::Bool=false,\nkeepDaysWithoutData::Bool=true,\nwindowSize::Int=5,\nriskFreeRate::Real=0.0\n)\n\nGiven an audit of the portfolio, account, events and OHLCV data it returns a summary of the performance \nof the portfolio over time.\n\n# Arguments\n- `data::DataFrame`: A dataframe with the data OHLCV_V1 data.\n- `context::ContextTypeA`: Result from running the simulation in DEDS Engine.\n### Optional keyword arguments\n-`valuationFun::Function=stockValuation`: Stock needs to be valued to establish a notion of returns. This allows to pass custom functions for asset valuation.\n-`removeWeekend::Bool=false`: Many markets close over weekend. If events are kept with lack of activity returns of 0 may be observed.\n-`keepDaysWithoutData::Bool=true`: Without data the most recent  market provided will be used to estimate the value of assets. If events are kept with lack of activity returns of 0 may be observed.\n-`windowSize::Int=5`: Many statistical figures are observed over sliding time windows, this allows to select the size of the timewindows by setting the number of consecutive events considered.\n-`riskFreeRate::Real=0.0`: Sharpe and other metrics rely on a definition of a risk free rate. \n-`includeAccounts::Bool=true`: By default we assume that the account is not reflected in the portfolio, if accounts are included in the portfolio set *includeAccounts* to false to avoid double counting the value of money in the account.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.deepPush!-Tuple{Any, Any}","page":"Autodocs","title":"AirBorne.Utils.deepPush!","text":"deepPush!(list,element)\n\nInserts the deepcopy of an element into a collection \n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.get_latest-Tuple{Any, Any, Any}","page":"Autodocs","title":"AirBorne.Utils.get_latest","text":"get_latest(df,id_symbols,sort_symbol)\n\nRetrieves last record from a dataframe, sortying by sort_symbol and grouping by id_symbols.\n\n```julia\nget_latest(past_data,[:exchangeName,:symbol],:date)\n```\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.get_latest_N-Tuple{Union{DataFrames.DataFrame, DataFrames.SubDataFrame}, Symbol, Int64}","page":"Autodocs","title":"AirBorne.Utils.get_latest_N","text":"get_latest_N(sdf::Union{SubDataFrame,DataFrame},by::Symbol,N::Int64; rev=false,fields::Vector=[])\n\nThis function returns a DataFrame with the first N rows of the input dataframe sorted by the column *by* amd the columns specified by *fields*. \n\nUsing the additional parameter, *rev* the sort order gets reversed. \n\nExample: get the 5 largest companies in the NASDAQ screener, per sector.\n```julia\n    using AirBorne.ETL.NASDAQ: screener\n    tickers_df = screener()\n    filtered_df =tickers_df[[   x!=\"\" ? parse(Int64, x)<2017 : false for x in tickers_df.ipoyear],[\"symbol\",\"marketCap\",\"sector\"]]\n    grouped_df = groupby(filtered_df,\"sector\")\n    f(sdf)= get_latest_N(sdf,:marketCap,5;rev=true, fields = [\"symbol\", \"marketCap\"])\n    result = combine(gdf,f)\n```\nAnother example\n```\na=\"A\";b=\"B\"\n\nf2(sdf)= get_latest_N(sdf,:val,3)\ndf =DataFrame(Dict(\n        \"cat\"=>[a,a,a,a,a,b,b,b,b,b],\n        \"val\"=>[5,3,2,6,1,4,3,8,6,2],\n         \"ix\"=>[1,2,3,4,5,6,7,8,9,10],\n))\ncombine(groupby(df,\"cat\"),f2)\n# 6×3 DataFrame\n# Row\tcat\t    ix\t    val\n#       String\tInt64\tInt64\n# 1     A\t    5\t    1\n# 2     A\t    3\t    2\n# 3     A\t    2\t    3\n# 4     B\t    10\t    2\n# 5     B\t    7\t    3\n# 6     B\t    6\t    4\n```\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.hello_world-Tuple{}","page":"Autodocs","title":"AirBorne.Utils.hello_world","text":"hello_world()\n\nReturns a string saying \"Hello World!\".\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.lagFill-Tuple{Vector}","page":"Autodocs","title":"AirBorne.Utils.lagFill","text":"lagFill(df::DataFrame,col::Symbol; fill::Vector=[missing,nothing]))\n\nReplaces all missing values in a column of a dataframe for the previous \nnon-missing value.\n### Arguments\n-`inV::Vector`: Input Vector\n-`fill::Vector`: Vector with elements to be filled. I.e., nothing, NaN, missing. By default: [missing,nothing].\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.makeRunning-Tuple{Vector, Function}","page":"Autodocs","title":"AirBorne.Utils.makeRunning","text":"Given a function (mean, variance, sharpe,...) from an 1-D array to a single element\nIt creates an array with same size of original with the function applied from the \nbeginning of the array to the index of the output. \n\n!!! Tip \"Performance\"\n    This function is not meant to be highly performant. If a function is used function is\n    advised to have a specialized function to calculate its running counterpart.\n\n# Optional Arguments\n- `windowSize::Union{Int,Nothing}`: If its desired to truncate the number of past elements to be considered, this field can be set to the maximum number of past elements to take into account. This can be used for Moving Averages for example. \n- `ignoreFirst::Int`: Indicates for how many elements the operation should not be applied. In those elements \"nothing\" will be placed instead.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.movingAverage-Tuple{Vector}","page":"Autodocs","title":"AirBorne.Utils.movingAverage","text":"More efficient implementation of a moving average (mean running).\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.rblockdiag-Tuple{Union{Vector{Matrix{Float64}}, Vector{Matrix{Int64}}}}","page":"Autodocs","title":"AirBorne.Utils.rblockdiag","text":"Recursive block diagonal \n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.rvcat-Tuple{Any}","page":"Autodocs","title":"AirBorne.Utils.rvcat","text":"rvcat(v): Recursive vcat.\n\nvcat has limited support for sparce matrices, this function allows to vertically concatenate \nsparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.sortStruct!-Tuple{Vector, Any}","page":"Autodocs","title":"AirBorne.Utils.sortStruct!","text":"sortStruct!(v::Vector, symbol;rev=true) \n\nSorts a struct by a given symbol.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.sortedStructInsert!-Tuple{Vector, Any, Any}","page":"Autodocs","title":"AirBorne.Utils.sortedStructInsert!","text":"sortedStructInsert!(v::Vector, x,symbol;rev=true) \n\nInserts a struct into a sorted Vector of structs in the right place to keep the array sorted.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Utils.δ-Tuple{Any, Any}","page":"Autodocs","title":"AirBorne.Utils.δ","text":"Kronecker delta\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/","page":"Autodocs","title":"Autodocs","text":"Modules = [\n    AirBorne.ETL,\n    AirBorne.ETL.AssetValuation,\n    AirBorne.ETL.Cache,\n    AirBorne.ETL.Transform,\n    AirBorne.ETL.YFinance,\n    AirBorne.ETL.NASDAQ]","category":"page"},{"location":"pages/autodocs/#AirBorne.ETL","page":"Autodocs","title":"AirBorne.ETL","text":"This modules centralizes all features for the data pipeline of AirBorne including API\nconnections, cache management and data transformations as part of the data pipeline.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.ETL.AssetValuation","page":"Autodocs","title":"AirBorne.ETL.AssetValuation","text":"AssetValuation\n\nThis module provides standardized asset valuation techniques compatible with \ndatastructures in this module.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.ETL.AssetValuation.covariance-Tuple{DataFrames.DataFrame}","page":"Autodocs","title":"AirBorne.ETL.AssetValuation.covariance","text":"covariance(assetValuesdf::DataFrame)\n\nCalculates the covariance matrix given a Asset Value DataFrame or an Asset Return DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.AssetValuation.logreturns-Tuple{Vector}","page":"Autodocs","title":"AirBorne.ETL.AssetValuation.logreturns","text":"logreturns(array::Vector)\n\nCalculates the logarithmic returns in base 10 of the ratio with respect to the previous element. The return of the first element is set to 1 as the starting point.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.AssetValuation.returns-Tuple{DataFrames.DataFrame}","page":"Autodocs","title":"AirBorne.ETL.AssetValuation.returns","text":"returns(assetValuesdf::DataFrame) \n\nCalculates the returns of each ticker in the Asset Value DataFrame. By default as the relative percent with respect to the previous element,\nthe return of the first element is set to 0 as the starting point.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.AssetValuation.returns-Tuple{Vector}","page":"Autodocs","title":"AirBorne.ETL.AssetValuation.returns","text":"returns(array::Vector)\n\nCalculates the returns as relative percent with respect to the previous element. The return of the first element is set to 0 as the starting point.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.AssetValuation.sharpe-Tuple{Vector, Vector}","page":"Autodocs","title":"AirBorne.ETL.AssetValuation.sharpe","text":"sharpe(avgReturn::Vector,variance::Vector;riskFreeRate::Real=0.0)\n\nCalculates the sharpe ratio from 2 vectors of same length containing the mean and variance of the returns respectively.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.AssetValuation.sharpe-Tuple{Vector}","page":"Autodocs","title":"AirBorne.ETL.AssetValuation.sharpe","text":"sharpe(returns::Vector;riskFreeRate::Real=0.0,windowSize::Union{Int,Nothing}=nothing, startFrom::Int=1)\n\nCalculates the sharpe ratio from a single vector, by calculating its mean and variance over sliding \ntime windows.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.AssetValuation.stockValuation-Tuple{DataFrames.DataFrame}","page":"Autodocs","title":"AirBorne.ETL.AssetValuation.stockValuation","text":"stockValuation(data::DataFrame ;col::Symbol=:close,assetCol::Symbol=:assetID)\n\nProvides the value of individual tickers (share of an equity asset) at a certain \npoint in time given a OHLCV dataframe.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.AssetValuation.valuePortfolio-Tuple{Dict, Dict}","page":"Autodocs","title":"AirBorne.ETL.AssetValuation.valuePortfolio","text":"assetValue(data::DataFrame;method::Symbol=:last_open)\n\nProvides a method to calculate the value of an asset given some data.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.Cache","page":"Autodocs","title":"AirBorne.ETL.Cache","text":"This modules centralizes caching for the AirBorne package. Containing:\n- Definition of data storage procedures\n- Definition of data storage formats\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.ETL.Cache.describe_bundles-Tuple{}","page":"Autodocs","title":"AirBorne.ETL.Cache.describe_bundles","text":"describe_bundles(;archive=false)\n\nReturns the list of dictionaries describing the files for each bundle. \nIt allows to retrieve information about the archived files like:\n    - Status of the files (missing, corrupted, etc.)\n    - Schema\n    - Timestamp of storage\n    - File name\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.Cache.gen_id-Tuple{}","page":"Autodocs","title":"AirBorne.ETL.Cache.gen_id","text":"gen_id()\n\nGenerates an id based on the current UTC timestamp with format \"yyyy_mm_dd_H_M_S_s\"\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.Cache.get_cache_path-Tuple{}","page":"Autodocs","title":"AirBorne.ETL.Cache.get_cache_path","text":" get_cache_path()\n\nDefines the cache path depending on the OS and environment variables.\n```julia\njulia> import AirBorne\njulia> AirBorne.ETL.Cache.get_cache_path()\n```\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.Cache.hello_cache-Tuple{}","page":"Autodocs","title":"AirBorne.ETL.Cache.hello_cache","text":"hello_cache()\n\nReturns a string saying \"Hello Cache!\".\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.Cache.list_bundles-Tuple{}","page":"Autodocs","title":"AirBorne.ETL.Cache.list_bundles","text":"list_bundles()\n\nReturns the list of bundles available in the cached folder.\n\nIn the future this function can be expanded to return information as timestamp, \nformat of data in bundle among relevant metadata.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.Cache.load_bundle-Tuple{String}","page":"Autodocs","title":"AirBorne.ETL.Cache.load_bundle","text":"load_bundle(bundle_id::String)\n\nLoads data from a cached bundle.\n\n# Returns\nDataFrames.DataFrame\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.Cache.remove_bundle-Tuple{String}","page":"Autodocs","title":"AirBorne.ETL.Cache.remove_bundle","text":"remove_bundle(bundle_id::String; just_archive::Bool=false)\n\nRemoves bundle from cache. This is an irreversible operation. If just_archive is true it only flushes the archive folder.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.Cache.store_bundle-Tuple{DataFrames.DataFrame}","page":"Autodocs","title":"AirBorne.ETL.Cache.store_bundle","text":"store_bundle(data::DataFrames.DataFrame; bundle_id::Union{Nothing, String}=nothing, archive::Bool=true, meta::Dict=Dict(), c_meta::Dict=Dict())\n\nStores a dataframe in a bundle in parquet format.\n\n**Is very important that none of the columns are of type \"Any\"** as the storage for this column type is not defined.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.Transform","page":"Autodocs","title":"AirBorne.ETL.Transform","text":"Transform is the module were standard transformation between data structure takes place.\n\nParticular datasources should adhere to data structures defined in this module. In particular\nstrategies and markets may make use of data structures in this module in order to promote cross-compatibility \nbetween different strategies, markets and engines.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.ETL.YFinance","page":"Autodocs","title":"AirBorne.ETL.YFinance","text":"This modules provides an interface between AirBorne and Yahoo Finance API. \n\nFor ForEx to obtain 5m definition the requested range must be within the last 60 days.\n\nTo request ForEx data replace the ticker by `codeA*codeB*\"=X\"` i.e. to obtain the ForEx of USD and GBP the \nticker must be \"USDGBP=X\".\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.ETL.YFinance.get_chart_data-NTuple{4, Any}","page":"Autodocs","title":"AirBorne.ETL.YFinance.get_chart_data","text":"get_chart_data(symbol, period1, period2, freq)\n\nThis function calls the Yahoo chart API to get the OHCLV data.\nThe documentation for this function is based on [CryptoCoinTracker's guide](https://cryptocointracker.com/yahoo-finance/yahoo-finance-api#34a6032b7b9949a1876f4568e4961afd).\n\n# Arguments\n\n- `symbol::String`:  Ticker Symbol\n- `period1::String`:  UNIX Timestamp indicating the start of the data requested\n- `period2::String`:  UNIX Timestamp indicating the end time of the data requested \n- `freq::String`: The time interval between two data points. Can be 1m 2m 5m 15m 30m 60m 90m 1h 1d 5d 1wk 1mo 3mo.\n\n# Returns\n- r::HTTP.Messages.Response\n\n# Examples\n```julia\n# This example is untestable as it requires internet connection.\njulia> import AirBorne\njulia> r = AirBorne.ETL.YFinance.get_chart_data(\"AAPL\",\"1577836800\",\"1580515200\",\"1d\")\n```\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.YFinance.get_interday_data-Tuple{Any, Any, Any}","page":"Autodocs","title":"AirBorne.ETL.YFinance.get_interday_data","text":"function get_interday_data(symbols, period1, period2)\n\nUse this function to get interday data for different tickers from Yahoo charts API.\n# Arguments\n- `symbols::String`:  Ticker Symbol\n- `period1::String`:  UNIX Timestamp indicating the start of the data requested\n- `period2::String`:  UNIX Timestamp indicating the end time of the data requested \n\n# Example\n```julia\nimport AirBorne\ndata = AirBorne.ETL.YFinance.get_interday_data([\"AAPL\",\"GOOG\"],\"1577836800\",\"1580515200\")\n```\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.YFinance.hello_yfinance-Tuple{}","page":"Autodocs","title":"AirBorne.ETL.YFinance.hello_yfinance","text":"hello_yfinance()\n\ns a string saying \"Hello YFinance!\".\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.ETL.NASDAQ","page":"Autodocs","title":"AirBorne.ETL.NASDAQ","text":"This modules provides an interface between AirBorne and NASDAQ API.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.ETL.NASDAQ.screener-Tuple{}","page":"Autodocs","title":"AirBorne.ETL.NASDAQ.screener","text":"screener()\n\nReturns the data from  [NASDAQ's screner page](https://www.nasdaq.com/market-activity/stocks/screener).\n\nIt provides a simple way also of getting a relatively large amount of US tickers.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/","page":"Autodocs","title":"Autodocs","text":"Modules = [AirBorne.Markets,AirBorne.Markets.StaticMarket]","category":"page"},{"location":"pages/autodocs/#AirBorne.Markets","page":"Autodocs","title":"AirBorne.Markets","text":"Strategies\n\nThis module centralizes access to different market models.\n\nA market model is tuple with a module and a struct that can be used to simulate/estimate the execution of orders.  \n\nA market can represent a stock exchange like NYSE or secondary markets.\n\nAssumptions made during the modelling of the market will have a direct impact on the results from backtesting,\nany result from backtesting should be referenced to a strategy and a market model.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket","page":"Autodocs","title":"AirBorne.Markets.StaticMarket","text":"StaticMarket\n\nThe static market assumes that the prices of the assets are not affected by the strategy used. \n\nThis is a big assumption for large orders but for smaller ones it can hold.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.Order","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.Order","text":"Order\n\nRepresents an order to the market. I.e. A stock exchange. \n\nTODO: Add more documentation\n\n\n\n\n\n","category":"type"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.addJournalEntryToLedger!-Tuple{Vector{Any}, Union{DotMaps.DotMap, Dict}}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.addJournalEntryToLedger!","text":"addJournalEntryToLedger!(ledger::Vector{Any},journal_entry::Union{DotMap,Dict})\n\nStaticMarket method to add journal entries to ledger.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.addMoneyToAccount!-Tuple{DotMaps.DotMap, Any}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.addMoneyToAccount!","text":"addMoneyToAccount!(account::DotMap, journal_entry)    \n\nStaticMarket method to add money to the accounts given an entry to ledger.\nThe convention is that a positive ledger entry correspond to money exiting the account.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.addSecurityToPortfolio!-Tuple{Union{DotMaps.DotMap, Dict}, Union{DotMaps.DotMap, Dict}}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.addSecurityToPortfolio!","text":"addSecurityToPortfolio!(portfolio::Union{DotMap,Dict},journal_entry::Union{DotMap,Dict})\n\nStaticMarket method to add  securities to portfolios .\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.available_data-Tuple{Any, Any}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.available_data","text":"available_data(context,data)\n\nThis function determine what data is available given the context.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.executeOrder_CA-Tuple{AirBorne.Structures.ContextTypeA, Order, DataFrames.DataFrame}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.executeOrder_CA","text":"executeOrderCA(     context::ContextTypeA, order::Order, curdata::DataFrame; priceModel::Function=refPrice )     Default order execution method when using ContextTypeA in the simulation.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.execute_orders!-Tuple{AirBorne.Structures.ContextTypeA, DataFrames.DataFrame}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.execute_orders!","text":"execute_orders(\n    context::ContextTypeA, data::DataFrame; executeOrder::Function=executeOrder_CA; propagateBalanceToPortfolio::Bool=false\n    )\n\nThis function updates the portfolio of the user that is stored in the variable context.\n\nThe static Market assumes that orders do not modify market attributes. Therefore orders can be executed\nsequentially without consideration on how the order on one asset may affect the price on another.\n\n-`propagateBalanceToPortfolio::Bool=false`: If the balance of the account needs to also be reflected in the portfolio \n    set this value to true and the value of *order.specs.account.currency* in the portfolio will be replaced by *order.specs.account.balance*.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.expose_data-Tuple{AirBorne.Structures.ContextTypeA, DataFrames.DataFrame}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.expose_data","text":"expose_data(context,data)\n\nThis function determine how the data is transformed and filtered before being passed to the user.\n\n# Arguments\n-`context::ContextTypeA`: Context of the simulation.\n- `data::DataFrame`: The dataframe provided to the simulation. \n### Optional keyword arguments\n-`historical::Bool=true`: If true returns data up to the specified event in the context, otherwise returns just data matching the\ntime of the current event of the context.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.genOrder-Tuple{Union{String, Symbol}, Real}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.genOrder","text":"genOrder(assetId::Union{String,Symbol},amount::Real; account::Any=nothing,orderType::String=\"MarketOrder\")\n\nShortcut to generate market orders, in it the assetId is defined by \"ExchangeID/TickerSymol\", \namount is a real number with the number of shares to be purchased, account is the account to be used to\nprovide the money for the transaction and order type is the type of the order.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.keyJE-Tuple{Union{DotMaps.DotMap, Dict}}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.keyJE","text":"Defines the unique identifier to an equity asset given a journal entry of the ledger\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.ordersForPortfolioRedistribution-Tuple{Dict{String, Float64}, Dict{String, Float64}, Dict{String, Float64}}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.ordersForPortfolioRedistribution","text":"ordersForPortfolioRedistribution(\n    sourcePortfolio::Dict{String, Float64}, \n    targetDistribution::Dict{String, Float64},\n    assetPricing::Dict{String, Float64};\n    curency_symbol::String= \"FEX/USD\", \n    account::Any=nothing,\n    costPropFactor::Real=0,\n    costPerTransactionFactor::Real=0,\n    )\nThis function generates the orders to obtain a particular value distribution on a given portfolio and static pricing.\nIt can consider proportional costs by scaling the orders amount by a factor and a fixed cost for each transacted asset.\nIt returns the portfolio with the desired distribution and the maximum amount of value expressed in a particular currency.\n\n-`sourcePortfolio::Dict{String, Float64}`: Dictionary with assets and how many units of them are present in a portfolio \n-`targetDistribution::Dict{String, Float64}`: Desired distribution of the total value of the portfolio across the whole shares. The values do not need to add to 1, linear scaling will be used.\n-`assetPricing::Dict{String, Float64}`: Value of each share of an asset, with a corresponding value expressed in terms of a currency.\n-`curency_symbol::String= \"FEX/USD\"`: Symbol used to represent the currency in which the transactions are goint to take place. By default dollars, it should have value 1 on the assetPricing dictionary.\n-`account::Any=nothing`: Argument to be passed to the account field in the orders.\n-`costPropFactor::Real=0`:  Fee rate applied to the sell or purchase of any asset proportional to the value of the transaction.\n-`costPerTransactionFactor::Real=0`: Fee per transaction, every time an asset is sold/bought this fill will apply.\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Markets.StaticMarket.refPrice-Tuple{DataFrames.DataFrame, Union{String, Symbol}}","page":"Autodocs","title":"AirBorne.Markets.StaticMarket.refPrice","text":"refPrice(cur_data::DataFrame, ticker::Union{String,Symbol}; col::Symbol=:open)\n\nUsing the current data in the market establishes the price to be paid per a unit of an asset \n(a share for example in equity).\n\nAssuming a dataframe with one row per ticker where the ticker symbol is in the column symbol\nThe price is assumed to be at the column \"col\"\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/","page":"Autodocs","title":"Autodocs","text":"Modules = [AirBorne.Engines,AirBorne.Engines.DEDS]","category":"page"},{"location":"pages/autodocs/#AirBorne.Engines","page":"Autodocs","title":"AirBorne.Engines","text":"This modules centralizes all features for strategy backtesting including different simulation archetypes.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.Engines.DEDS","page":"Autodocs","title":"AirBorne.Engines.DEDS","text":"DEDS - Which stands for \"Discrete Event Driven Simulation\"  is a framework for backtesting\nwhere the system moves from one event to the next one.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.Engines.DEDS.hello_deds-Tuple{}","page":"Autodocs","title":"AirBorne.Engines.DEDS.hello_deds","text":"DEDS module hello world\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Engines.DEDS.run-Tuple{DataFrames.DataFrame, Vararg{Function, 4}}","page":"Autodocs","title":"AirBorne.Engines.DEDS.run","text":"run(data::DataFrame, initialize!::Function, trading_logic!::Function, execute_orders!::Function,expose_data::Function;audit=true)\n\nRun DEDS simulation provided:\n# Arguments\n- `data::DataFrame`: A dataframe with the data to be provided to the function `expose_data` and `Function, execute_orders!`.\n- `initialize!::Function`: initialize!(context) should receive a struct context and provide initialization for its accounts \n    and add as the next events to be processed by this function.\n- `trading_logic!::Function`: `trading_logic!(context,exposed_data)` receives the context and exposed data from the market \n  and should place orders and define further events \n- `execute_orders!::Function`: execute_orders!(past_event_date, context.current_event.date, context, data) Executes orders between\n    the past event and the current one, this function will modify the portfolio and the accounts from the context.\n### Optional keyword arguments\n- `audit::Bool=true`: If true context will its audit entry populated for each event in the simulation. \n- `max_iter::Int=10^6`: Limit the number of events processed on the simulation.\n# Returns\n- `verbose::Bool=false`: If true prints the date\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/","page":"Autodocs","title":"Autodocs","text":"Modules = [AirBorne.Strategies,AirBorne.Strategies.SMA,AirBorne.Strategies.Markowitz,AirBorne.Strategies.MeanVarianceMPC]","category":"page"},{"location":"pages/autodocs/#AirBorne.Strategies","page":"Autodocs","title":"AirBorne.Strategies","text":"Strategies\n\nThis module centralizes access to different trading strategy templates.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.Strategies.SMA","page":"Autodocs","title":"AirBorne.Strategies.SMA","text":"SMA (Simple Moving Average)\n\nThis is a standard strategy that can be implemented in several ways.\n\n1. Crossover Simple Moving Average: Define 2 time windows, a long one and a short one.\nIf the Average during the short one is greater than over the long one this implies that the price  is going up.\nSo a long position is desired, however if its smaller then this indicates a falling price and a short position \nis desired.\n\nIn this Strategy an optimization of hyperparameters will be available. The optimization will need an objective function and \nmaybe constraints.\n\nThe design of this strategy is inspired by the lecture 2 of Algorithmic Trading, original source obtained from  [Algorithmic Trading Society Lectures Imperial College London](https://github.com/algotradingsoc/Lectures2022/blob/main/AlgoTradeSocLectures.ipynb)\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.Strategies.SMA.interday_initialize!-Tuple{AirBorne.Structures.ContextTypeA}","page":"Autodocs","title":"AirBorne.Strategies.SMA.interday_initialize!","text":"initialize!\n\nTemplate for the initialization procedure, before being passed onto an engine like DEDS a preloaded\nfunction must be defined so that the initialization function meets the engine requirements.\n\n```julia\n# Specify custom arguments to tune the behaviour of SMA\nmy_initialize!(context,data) = SMA.initialize!(context;...)\n# Or just run with the default parameters\nmy_initialize!(context,data) = SMA.trading_logic!(context)\n```\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Strategies.SMA.interday_trading_logic!-Tuple{AirBorne.Structures.ContextTypeA, DataFrames.DataFrame}","page":"Autodocs","title":"AirBorne.Strategies.SMA.interday_trading_logic!","text":"interday_trading_logic!(context::ContextTypeA, data::DataFrame)\n\nTemplate for the trading logic algorithm, before being passed onto an engine like DEDS a preloaded\nfunction must be defined so that the trading logic function meets the engine requirements.\n\n```julia\n# Specify custom arguments to tune the behaviour of SMA\nmy_trading_logic!(context,data) = SMA.trading_logic!(context,data;...)\n# Or just run with the default parameters\nmy_trading_logic!(context,data) = SMA.trading_logic!(context,data)\n```\n\n\n\n\n\n","category":"method"},{"location":"pages/autodocs/#AirBorne.Strategies.Markowitz","page":"Autodocs","title":"AirBorne.Strategies.Markowitz","text":"Markowits Portfolio Optimization\n\nIt assumes the returns of the individual stocks to be a stationary stochastic process, not necessarily \nindependent. Therefore it has a constant mean and variance matrix for the asset returns.\n\n\nFrom stock prices it assumes the returns to be \nThis implementation follow the one in [JuMP non-linear Portfolio Optimization](https://jump.dev/JuMP.jl/stable/tutorials/nonlinear/portfolio/)\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.Strategies.MeanVarianceMPC","page":"Autodocs","title":"AirBorne.Strategies.MeanVarianceMPC","text":"MeanVarianceMPC\n\nThis module provides a template strategy we call Mean Variance Model Predictive Control or Mean-Variance MPC for short.\n\nThis strategy provides seeks the set of optimal portfolio distributions over time considering the cost of changing positions and \na forecast on the expected returns and as well covariance matrix of returns.\n\n\n\n\n\n","category":"module"},{"location":"pages/autodocs/#AirBorne.Strategies.MeanVarianceMPC.predeterminedReturns-Tuple{AirBorne.Structures.ContextTypeA, DataFrames.DataFrame}","page":"Autodocs","title":"AirBorne.Strategies.MeanVarianceMPC.predeterminedReturns","text":"predeterminedReturns(context::ContextTypeA,returnData::DataFrame)\n\nReturns a sequence of tuples with (returnVector,CovarianceMatrix). Since the values of the predeterminedReturns is assumed to be known constants\nthe variance and convariance between assets is set to 0.\n\n-`returnData::DataFrame`: Dataframe that has one row per time and a column per assetID at least containing the elements of *context.extra.symbolOrder*. Each \nentry on the dataframe corresponds to the return of 1 unit of the assetId of the corresponding column between the time of the previous row and its corresponding row .\n\nTo use this function context needs to have defined the following attributes:\n-`context.extra.symbolOrder::Vector{String}`: The order in which the return and covariance matrix vector should be expressed.\n-`context.current_event::TimeEvent`: The current event of the simulation. (Mandatory for context)\n-`context.parameters.horizon::Int64`: The number of sequences to be read from returnData and transformed into tuples of return vector and variance matrices.\n\nTo use this forecast in the tradingLogicMPC! strategy\n```julia\n    forecastFun(context) = predeterminedReturns(context, returnsData) # returnsData must already be defined.\n    custom_trading_logic!(context,data) = tradingLogicMPC!(context,data;forecastFun=forecastFun) \n```\n\n\n\n\n\n","category":"method"},{"location":"pages/examples/Strategies/#Example:-Building-Strategies-for-DEDS-and-Static-Markets","page":"Strategies","title":"Example: Building Strategies for DEDS & Static Markets","text":"","category":"section"},{"location":"pages/examples/Strategies/","page":"Strategies","title":"Strategies","text":"In this page you will find examples on the creation of strategies.","category":"page"},{"location":"pages/examples/Strategies/#[Building-a-Simple-Moving-Average-Strategy](https://github.com/JuDO-dev/AirBorne.jl/blob/markowitz/docs/example_notebooks/SMA_Example.ipynb).","page":"Strategies","title":"Building a Simple Moving Average Strategy.","text":"","category":"section"},{"location":"pages/examples/Strategies/","page":"Strategies","title":"Strategies","text":"This example will show you how to build a simple moving average strategy for a Static Market using the Discrete Event Driven Simulation (DEDS) egine as well as an introduction to the template provided by AirBorne.jl. ","category":"page"},{"location":"pages/examples/Strategies/","page":"Strategies","title":"Strategies","text":"The SMA strategy takes the average return over 2 time windows known as the short horizon and the long horizon. If the short horizon average is greater than the long horizon average then we assume that the asset is increasing in value and we tend to buy such asset, when the condition is no longer met all the shares of such asset are sold.","category":"page"},{"location":"pages/examples/Strategies/","page":"Strategies","title":"Strategies","text":"The full example can be found in the AirBorne.jl repository in the form of a Jupyter Notebook following this link.","category":"page"},{"location":"pages/examples/Strategies/#[Building-a-Markowitz-Strategy](https://github.com/JuDO-dev/AirBorne.jl/blob/markowitz/docs/example_notebooks/Markowitz_Example.ipynb).","page":"Strategies","title":"Building a Markowitz Strategy.","text":"","category":"section"},{"location":"pages/examples/Strategies/","page":"Strategies","title":"Strategies","text":"This example will show you how to build a markotiz strategy for a Static Market using the Discrete Event Driven Simulation (DEDS) egine as well as an introduction to the template provided by AirBorne.jl. ","category":"page"},{"location":"pages/examples/Strategies/","page":"Strategies","title":"Strategies","text":"The Markowtiz strategy models the returns of each asset as random variables, with mean, variance and covariance, the objective in the Markowitz  strategy is that given a desired expected return to organize a portfolio with the minimum possible variance. ","category":"page"},{"location":"pages/examples/Strategies/","page":"Strategies","title":"Strategies","text":"The full example can be found in the AirBorne.jl repository in the form of a Jupyter Notebook following this link.","category":"page"},{"location":"pages/financialModelling/#Financial-Modelling","page":"Financial Modelling","title":"Financial Modelling","text":"","category":"section"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"This page describes the modelling behind different financial structures and data types.","category":"page"},{"location":"pages/financialModelling/#Money,-Currency-and-Wallets","page":"Financial Modelling","title":"Money, Currency and Wallets","text":"","category":"section"},{"location":"pages/financialModelling/#Money","page":"Financial Modelling","title":"Money","text":"","category":"section"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"AirBorne provides a self-contained representation of money. Money is represented as a number with an associated Symbol parameter type that acts as the currency. Money with the same currency can be added together and Money can be multiplied by any real number. However Money cannot be multiplied by Money.","category":"page"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"AirBorne is fully compatible with the module Currencies. But it can also support currencies outside ISO 4217, because the implementation of a currency is just through a Symbol representation.","category":"page"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"    using AirBorne: Money\n    using Currencies: Currencies\n    USD = Currencies.currency(:USD)\n    GBP = Currencies.currency(:GBP)\n    UYU = Currencies.currency(:UYU)\n    a = 10USD\n    b = 10.0USD\n    c1 = Money{:GBP}(5.0)\n    c2 = Money{:GBP}(5)\n    # All the expression below are equivalent and should return true.\n    println(2.0 * a == (b + b))\n    println(2.0 * a == b * 2)\n    println(2 * a == b * 2.0)\n    println(USD * 2 == USD * 2.0)","category":"page"},{"location":"pages/financialModelling/#Wallets","page":"Financial Modelling","title":"Wallets","text":"","category":"section"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"A Wallet is a collection of different types of Money. At its core is a dictionary with extra features for algebraic operations as one can add Money to a Wallet just by using the \"+\" operator, and wallets can be added together using the \"+\" operator as well. Moreover if a particular currency is not present in a wallet if you try to retrieve the amount of such currency from the wallet the answer will be 0 (instead of a KeyError response).","category":"page"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"    using AirBorne: Money, Wallet\n    using Currencies: Currencies\n    USD = Currencies.currency(:USD)\n    GBP = Currencies.currency(:GBP)\n    UYU = Currencies.currency(:UYU)\n    \n    # Different ways to instantiate a wallet\n    w0 = Wallet(USD) \n    w1 = Wallet(:USD)\n    w2 = Wallet(20USD)\n    w3 = Wallet(50UYU)\n    w4 = Wallet(Dict(:USD => 20, :UYU => 50))\n    w5 = deepcopy(w3)\n    w5[:USD] = 10.0 # Define up the amount of USD in Wallet\n\n    # Arithmetic operations between wallets and money\n    w2 + 50UYU == w4 # Add money to wallet\n    20USD + w3 == w4 # Commutative property of addition\n    w2 + w3 == w4 # Combine wallets\n    20USD + 50UYU == w4 # Generate a wallet by adding different types of Money\n    \n\n    # Operations with keys\n    haskey(w5, :USD) # Check if wallet has currency defined\n    collect(keys(w5)) == [:UYU, :USD] # Get currencies in Wallet","category":"page"},{"location":"pages/financialModelling/#DataFrames-Structures","page":"Financial Modelling","title":"DataFrames Structures","text":"","category":"section"},{"location":"pages/financialModelling/#OHLCV-V1-DataFrame","page":"Financial Modelling","title":"OHLCV V1 DataFrame","text":"","category":"section"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"This is a standard format for the storage of equity asset information, the schema of this format of data is defined in AirBorne.ETL.Transform.","category":"page"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"OHLCV_V1_specs = [\n    :close; Float64;; # Tipical OHLCV candles\n    :high; Float64;;\n    :low; Float64;;\n    :open; Float64;;\n    :volume; Int64;; \n    :date; Dates.DateTime;; # DateTime Timestamp\n    :unix; Int64;; # Unix timestamp\n    :exchangeName; String;; # Name of the exchange trading the security\n    :timezone; String;; # Timezone of the exchange\n    :currency; String;; # Currency used to trade an asset in the exchange\n    :symbol; String;; # Symbol of the asset in the exchange\n    :assetId; String # Combination of the asset and the exchange that uniquely specifies the asset to be traded and the environment.\n]","category":"page"},{"location":"pages/financialModelling/#Asset-Value-DataFrame","page":"Financial Modelling","title":"Asset Value DataFrame","text":"","category":"section"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"This dataframe contains one column per ticker/asset and one row per timestamp. The value of each column corresponds to the value of the asset at the specified point in time of the row.","category":"page"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"Additionally the dataframe contains an additional column stockValue that summarizes the values of all the assets in a dictionary with keys the ticker symbols and values the value of the unit of asset.","category":"page"},{"location":"pages/financialModelling/#Asset-Return-DataFrame","page":"Financial Modelling","title":"Asset Return DataFrame","text":"","category":"section"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"Similar to the Asset Value DataFrame this dataframe contains one column per ticker/asset and one row per timestamp. The value of each column corresponds to the return of the asset at the specified point in time of the row. This is usually defined with respect to the previous timestamp. The first return value is by default set to 0.","category":"page"},{"location":"pages/financialModelling/","page":"Financial Modelling","title":"Financial Modelling","text":"Additionally the dataframe contains an additional column stockReturn that summarizes the returns of all the assets in a dictionary with keys the ticker symbols and values the return of the unit of asset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AirBorne","category":"page"},{"location":"#AirBorne","page":"Home","title":"AirBorne","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for AirBorne!","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this documentation you will find descriptions for the methods of the package, reasoning and sources for our high-level design and examples showing how this package can be leveraged. ","category":"page"},{"location":"pages/backtesting/eventDrivenSimulation/#Backtesting-and-Event-Driven-Simulation","page":"Event Driven Simulation","title":"Backtesting and Event Driven Simulation","text":"","category":"section"},{"location":"pages/backtesting/eventDrivenSimulation/","page":"Event Driven Simulation","title":"Event Driven Simulation","text":"In this section the main principles guiding the Event Driven Simulation engine used for backtesting is laid out.","category":"page"},{"location":"pages/backtesting/eventDrivenSimulation/#Guiding-Principles","page":"Event Driven Simulation","title":"Guiding Principles","text":"","category":"section"},{"location":"pages/backtesting/eventDrivenSimulation/","page":"Event Driven Simulation","title":"Event Driven Simulation","text":"The driving principles for backtesting are the following:","category":"page"},{"location":"pages/backtesting/eventDrivenSimulation/","page":"Event Driven Simulation","title":"Event Driven Simulation","text":"Speedeness: The simulation should be fast, extremely fast, so that most of the computational resources can be allocated to calculations that the user wants to do within the simulation. \nTransparency: Calculations should be as accurate, explainable and reproducible. Meaning that a user with some level of proficiency in Excel should be able to get back most of the calculations based solely on the description of the simulation and its calculations obtained in the documentation.\nRealism: From the user perspective the procedure of the simulation should have a strong correlation to what they would expect to see when trading in real life.","category":"page"},{"location":"pages/backtesting/eventDrivenSimulation/#Design","page":"Event Driven Simulation","title":"Design","text":"","category":"section"},{"location":"pages/backtesting/eventDrivenSimulation/","page":"Event Driven Simulation","title":"Event Driven Simulation","text":"The objective of event driven simulation is to do calculations only when necessary and making them as small as possible whilst at the same time having as many simulation points as needed to achieve realism.","category":"page"},{"location":"pages/backtesting/eventDrivenSimulation/","page":"Event Driven Simulation","title":"Event Driven Simulation","text":"Simulation starts by defining the event_queue which is a list of events, each event carries with them a timestamp and some minimal metadata that determines the workflow of the simulation.\nAt the beginning of the routine a special event called initialization_event is defined and added to the queue starting the simulation.\nAt the initialization_event the initialize method of the agent is called.\nDuring this stage the agent should decide how often the market(s) sends him data by either specifying a frequency or scheduling a future releasedataevent event for a particular market(s).\nDuring this stage a Dictionary context will be created, this variable will be propagated throughout the simulation./\nIf desired the agent can also perform actions such as place orders through a broker the orders placed will be placed in a list called order_queue.\nDuring this stage the broker used and its fee structure needs to also be defined, it can be modified at any point down the line but is assumed that the transactions are done through a broker during the simulation. Special broker to simulate the direct trade by the agent can also be put in place within this framework.  \nAt the end of the event brokers shall decide how to execute the order by interacting with markets generating a list of orderexecutionqueue.\nThen each market will execute the orders in unobservable  events that are communicated to brokers with potentially some delay or noise. Is worth noticing that some orders may have triggering conditions like sell only for a certain amount of currency for example, therefore the triggering of the execution will be left to the market through execution_events. execution_events can also include the payment of dividends. \nAt the releasedataevent the  handle_data event is called. The data available is the data from a bundle with a timestamp smaller than the time of the event.","category":"page"},{"location":"pages/backtesting/eventDrivenSimulation/","page":"Event Driven Simulation","title":"Event Driven Simulation","text":"This framework allows to have variable timewindows for the agent controlled dynamically by the agent himself.","category":"page"},{"location":"pages/backtesting/eventDrivenSimulation/#Engines","page":"Event Driven Simulation","title":"Engines","text":"","category":"section"},{"location":"pages/backtesting/eventDrivenSimulation/#DEDS","page":"Event Driven Simulation","title":"DEDS","text":"","category":"section"},{"location":"pages/backtesting/eventDrivenSimulation/","page":"Event Driven Simulation","title":"Event Driven Simulation","text":"Deterministic Event Driven Simulation (DEDS) is an engine that executes a series of events where a Market and a User interact with each other. The simulation iterates over a series of events allowing the user to retrieve data from the market and place orders, then the market executes the orders in between consecutive events.","category":"page"},{"location":"pages/backtesting/eventDrivenSimulation/","page":"Event Driven Simulation","title":"Event Driven Simulation","text":"Below one can appreciate the logic behind the AirBorne.Engines.DEDS.run function, which is the run method for the DEDS engine.","category":"page"},{"location":"pages/backtesting/eventDrivenSimulation/","page":"Event Driven Simulation","title":"Event Driven Simulation","text":"(Image: DEDS_run)","category":"page"}]
}
